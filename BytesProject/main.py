import numpy
import os
import glob
import shutil as sp
from multiprocessing import Pool

path = r"E:\malwaretrain\train"
trainLabels = "trainLabels.txt"
save_path_first = r"E:\malwaretxttrainclasses\first"
save_path_second = r"E:\malwaretxttrainclasses\second"
save_path_third = r"E:\malwaretxttrainclasses\third"
save_path_fourth = r"E:\malwaretxttrainclasses\fourth"
save_path_fifth = r"E:\malwaretxttrainclasses\fifth"
save_path_sixth = r"E:\malwaretxttrainclasses\sixth"
save_path_seventh = r"E:\malwaretxttrainclasses\seventh"
save_path_eighth = r"E:\malwaretxttrainclasses\eighth"
save_path_nineth = r"E:\malwaretxttrainclasses\nineth"
save_path_for_txt = r"E:\malwaretxttrain"

bytes_class = []
number_of_word = 16*4000

def read_classes_in(file):
    file_class_pair = []
    with open(file, 'r', encoding='utf-8') as f:
        while True:
            line = f.readline()
            if not line:
                break
            line = line[:-1]
            file_class_pair = line.split(',')
            bytes_class.append(file_class_pair)

def sorting(txt_path, txt_class):
    for txt in txt_path:
        name = os.path.basename(txt).split(".")[0]
        for subclass in txt_class:
            if name == subclass[0]:
                if subclass[1] == '1':
                    sp.copy2(txt, save_path_first)
                    break
                elif subclass[1] == '2':
                    sp.copy2(txt, save_path_second)
                    break
                elif subclass[1] == '3':
                    sp.copy2(txt, save_path_third)
                    break
                elif subclass[1] == '4':
                    sp.copy2(txt, save_path_fourth)
                    break
                elif subclass[1] == '5':
                    sp.copy2(txt, save_path_fifth)
                    break
                elif subclass[1] == '6':
                    sp.copy2(txt, save_path_sixth)
                    break
                elif subclass[1] == '7':
                    sp.copy2(txt, save_path_seventh)
                    break
                elif subclass[1] == '8':
                    sp.copy2(txt, save_path_eighth)
                    break
                elif subclass[1] == '9':
                    sp.copy2(txt, save_path_nineth)
                    break
                else:
                    break

def read_bytecode_in_and_make_txt(file):
    malwareLinesReaded = []
    malwareLinesSeparatedWithoutZero = []
    malwareLinesSeparatedDecimal = []
    with open(file, 'rb') as binary_file:
        name = os.path.basename(file).split(".")[0]
        while True:
            line = binary_file.readline()
            if not line:
                break
            malwareLine = line[9:-2]
            malwareLinesReaded.append(malwareLine.decode("utf-8"))
    binary_file.close()

    for x in malwareLinesReaded:
        byte = x.split()
        for y in range(len(byte)):
            try:
                byte[y] = int(byte[y], 16)
                if not byte[y] == 0:
                    malwareLinesSeparatedWithoutZero.append(byte[y])
            except:
                continue

    if len(malwareLinesSeparatedWithoutZero) < number_of_word:
        zeros_to_fill = number_of_word - len(malwareLinesSeparatedWithoutZero)
        for i in range(zeros_to_fill):
            malwareLinesSeparatedWithoutZero.append(0)

    completeFileName = os.path.join(save_path_for_txt, name) + '.txt'
    with open(completeFileName, 'w') as txt_to_write:
        for i in range(number_of_word):
            if (i+1) % 16 == 0:
                txt_to_write.write(str(malwareLinesSeparatedWithoutZero[i]) + '\n')
            elif i == number_of_word - 1:
                txt_to_write.write(str(malwareLinesSeparatedWithoutZero[i]))
            else:
                txt_to_write.write(str(malwareLinesSeparatedWithoutZero[i]) + ' ')


if __name__ == "__main__":
    read_classes_in(trainLabels)

    file_paths = []
    for file in glob.glob(path + "/*"):
        if file.endswith(".bytes"):
            file_paths.append(file)

    file_paths_txt = []
    for file in glob.glob(save_path_for_txt + "/*"):
        if file.endswith(".txt"):
            file_paths_txt.append(file)

    # with Pool(7) as p:
    #     p.map(read_bytecode_in_and_make_txt, file_paths)

    sorting(file_paths_txt, bytes_class)